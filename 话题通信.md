# 话题通信
---
# 发布方的实现
## 创建功能包
- 创建工作空间
```C
mkdir ROS2_WS
cd ROS2_WS
mkdir src
```
- 进入工作空间下的src目录
```C
cd ROS2_WS/src
```
- 创建功能包
```C
ros2 pkg create topicPKG --build-type ament_cmake --dependencies rclcpp --node-name pub
```
## 配置路径
![2](https://github.com/user-attachments/assets/b5c5f753-335d-414d-8f5d-b993e07a551b)
## 编写代码
```C
//发布方实现
/**
 * 需求：以某个固定频率发送文本“hello world”,文本后缀编号，每发送一条消息，标号递增1
 * 步骤：
 * 1.包含头文件
 * 2.初始化 ROS2 客户端
 * 3.定义节点类：
 *     3-1.创建发布方
 *     3-2.创建定时器
 *     3-3.组织消息并发布
 * 4.调用spin函数，并传入节点对象指针
 * 5.释放资源
 */

//1.包含头文件
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

using namespace rclcpp;
using namespace std;
using namespace chrono_literals;


//3.定义节点类
class pubNode:public Node
{
public:
  pubNode():Node("pub_node")
  {
    RCLCPP_INFO(this->get_logger(),"发布节点创建成功！");

    //3.1创建发布方  chatter 话题
    pub=this->create_publisher<std_msgs::msg::String>("chatter",10);
    //3.2创建定时器
    timer=this->create_wall_timer(1000ms,bind(&pubNode::pubMsg,this));
  }
  
private:

  //回调函数
  void pubMsg()
  {
    //组织消息
    auto message=std_msgs::msg::String();
    message.data="hello world->"+to_string(count);
    count++;
    RCLCPP_INFO(this->get_logger(),"发送消息：%s",message.data.c_str());

    //发布消息
    pub->publish(message);
  }
  Publisher<std_msgs::msg::String>::SharedPtr pub;//发布对象
  TimerBase::SharedPtr timer;//定时器对象
  ssize_t count=1;//计数器
};


int main(int argc,char** argv)
{
  //2.初始化 ROS2 客户端
  init(argc,argv);

  //4.调用spin函数，并传入节点对象指针
  spin(make_shared<pubNode>());//回旋用于一直调用回调函数

  //5.释放资源
  shutdown();
}
```
## 在 工作空间下 编译（/ROS2_WS/）
```C
colcon build
```
## source
```C
source install/setup.bash
```
## 运行
```C
ros2 run topicPKG pub
```
## 测试验证
```C
ros2 topic echo /chatter
```
## 提示
防止每次进入终端都需要source操作
- 主目录 ctrl+h 进入 .bashrc文件
- 添加
```C
# >>> source ROS2_WS >>>
source /home/oyh/ROS2_WS/install/setup.bash
# <<< source ROS2_WS <<<
```
# 订阅方实现
## 这里只提供代码
```C

```
